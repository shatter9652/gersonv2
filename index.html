<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Gerson Shield Fight</title>
  <style>
    body { margin: 0; background: black; overflow: hidden; }
    canvas { display: block; margin: 0 auto; }
  </style>
</head>
<body>
<canvas id="game" width="600" height="600"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const WIDTH = 600, HEIGHT = 600;
const CENTER = { x: WIDTH / 2, y: HEIGHT / 2 };
const FPS = 60;
const TRAVEL_TIME = 2.5;
const boxSize = 40;
const soulRadius = 10;
const DIRECTION_ORDER_8 = [0, 45, 90, 135, 180, 225, 270, 315];
const DIRECTION_NAMES = {
  0: 'right', 45: 'uright', 90: 'up', 135: 'uleft',
  180: 'left', 225: 'dleft', 270: 'down', 315: 'dright'
};
const DIRECTIONS = {
  0:[1,0], 45:[Math.SQRT1_2,-Math.SQRT1_2], 90:[0,-1],
  135:[-Math.SQRT1_2,-Math.SQRT1_2], 180:[-1,0],
  225:[-Math.SQRT1_2,Math.SQRT1_2], 270:[0,1], 315:[Math.SQRT1_2,Math.SQRT1_2]
};

let keys = {};
let shieldAngle = 90;
let octagonMode = false;
let arrows = [];
let arrowSpawnQueue = [];
let score = 0, highScore = 0, hp = 3;
let arrowsPerSec = 2, maxArrowsPerSec = 4;
let lastArrowAngle = 0;
let lastRamp = 12000;
let arrowTimer = 0;
let startTicks = 0;
let startScreen = true, gameOver = false;

// Asset loading
const soulImg = new Image();
soulImg.src = "assets/soul.png";

const arrowImgs = {}, redArrowImgs = {};
DIRECTION_ORDER_8.forEach(angle => {
  const name = DIRECTION_NAMES[angle];
  arrowImgs[angle] = new Image();
  arrowImgs[angle].src = `assets/arrow_${name}.png`;
  redArrowImgs[angle] = new Image();
  redArrowImgs[angle].src = `assets/red_arrow_${name}.png`;
});

const sfx_block = new Audio("assets/block.wav");
const sfx_hit = new Audio("assets/hurt.wav");
const sfx_gameOver = new Audio("assets/game_over.wav");
const music = new Audio("assets/music.ogg");
music.loop = true;
music.volume = 0.4;

function drawText(text, x, y, color = "white", size = 24) {
  ctx.fillStyle = color;
  ctx.font = `${size}px sans-serif`;
  ctx.fillText(text, x, y);
}

function drawSoul() {
  if (soulImg.complete) {
    ctx.drawImage(soulImg, CENTER.x - soulImg.width / 2, CENTER.y - soulImg.height / 2);
  } else {
    ctx.fillStyle = "white";
    ctx.beginPath();
    ctx.arc(CENTER.x, CENTER.y, soulRadius, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawShield() {
  const half = boxSize / 2;
  ctx.strokeStyle = "green";
  ctx.lineWidth = 1;

  if (!octagonMode) {
    ctx.strokeRect(CENTER.x - half, CENTER.y - half, boxSize, boxSize);
    ctx.strokeStyle = "white";
    ctx.lineWidth = 6;
    ctx.beginPath();
    if (shieldAngle === 90) ctx.moveTo(CENTER.x - half, CENTER.y - half), ctx.lineTo(CENTER.x + half, CENTER.y - half);
    if (shieldAngle === 270) ctx.moveTo(CENTER.x - half, CENTER.y + half), ctx.lineTo(CENTER.x + half, CENTER.y + half);
    if (shieldAngle === 180) ctx.moveTo(CENTER.x - half, CENTER.y - half), ctx.lineTo(CENTER.x - half, CENTER.y + half);
    if (shieldAngle === 0) ctx.moveTo(CENTER.x + half, CENTER.y - half), ctx.lineTo(CENTER.x + half, CENTER.y + half);
    ctx.stroke();
  } else {
    const r = boxSize / Math.sqrt(2);
    const pts = DIRECTION_ORDER_8.map((a) => ({
      x: CENTER.x + r * Math.cos((a - 22.5) * Math.PI / 180),
      y: CENTER.y - r * Math.sin((a - 22.5) * Math.PI / 180)
    }));
    ctx.beginPath();
    pts.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
    ctx.closePath();
    ctx.stroke();

    let idx = DIRECTION_ORDER_8.indexOf(shieldAngle);
    let p1 = pts[idx], p2 = pts[(idx + 1) % 8];
    ctx.strokeStyle = "white";
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.stroke();
  }
}

function drawArrows() {
  let closest = -1, minDist = Infinity;
  arrows.forEach((a, i) => {
    let dx = a.x - CENTER.x, dy = a.y - CENTER.y;
    let d = dx * dx + dy * dy;
    if (d < minDist) minDist = d, closest = i;
  });
  arrows.forEach((a, i) => {
    let img = i === closest ? redArrowImgs[a.angle] : arrowImgs[a.angle];
    if (img.complete) {
      ctx.drawImage(img, a.x - img.width / 2, a.y - img.height / 2);
    }
  });
}

function getDirectionFromKeys() {
  let up = keys["ArrowUp"], down = keys["ArrowDown"];
  let left = keys["ArrowLeft"], right = keys["ArrowRight"];
  if (!octagonMode) {
    if (up) return 90;
    if (down) return 270;
    if (left) return 180;
    if (right) return 0;
  } else {
    if (up && left) return 135;
    if (up && right) return 45;
    if (down && left) return 225;
    if (down && right) return 315;
    if (up) return 90;
    if (down) return 270;
    if (left) return 180;
    if (right) return 0;
  }
  return null;
}

function updateArrows() {
  let hitRadius = boxSize / 2 - 10;
  let blockRadius = boxSize / 2 + 10;
  arrows = arrows.filter((a) => {
    a.x += a.vx;
    a.y += a.vy;
    let dx = a.x - CENTER.x, dy = a.y - CENTER.y;
    let dist = Math.hypot(dx, dy);
    if (dist < hitRadius) {
      if (a.angle !== shieldAngle) {
        hp--;
        sfx_hit.play();
      }
      return false;
    } else if (dist < blockRadius && a.angle === shieldAngle) {
      score++;
      sfx_block.play();
      return false;
    }
    return true;
  });
}

function queueArrow() {
  let angle;
  if (octagonMode) {
    let roll = Math.random();
    let idx = DIRECTION_ORDER_8.indexOf(lastArrowAngle);
    if (roll < 0.25) angle = DIRECTION_ORDER_8[(idx - 1 + 8) % 8];
    else if (roll < 0.5) angle = DIRECTION_ORDER_8[(idx + 1) % 8];
    else angle = DIRECTION_ORDER_8[Math.floor(Math.random() * 8)];
  } else {
    angle = [0, 90, 180, 270][Math.floor(Math.random() * 4)];
  }
  lastArrowAngle = angle;
  let [dx, dy] = DIRECTIONS[angle];
  let speed = 2.5 + Math.random() * 3;
  let dist = speed * TRAVEL_TIME * FPS;
  let x = CENTER.x + dx * dist;
  let y = CENTER.y + dy * dist;
  arrowSpawnQueue.push({ spawnTime: Date.now() + TRAVEL_TIME * 1000, arrow: {
    x, y, vx: -dx * speed, vy: -dy * speed, angle
  }});
}

function gameLoop() {
  ctx.clearRect(0, 0, WIDTH, HEIGHT);
  const now = Date.now();

  if (startScreen) {
    drawText("GERSON SHIELD FIGHT", 150, 200, "green", 32);
    drawText("Use arrow keys to rotate the shield.", 130, 240);
    drawText("Block arrows from hitting the soul.", 130, 270);
    drawText("Press any key to start!", 180, 320, "gold");
    drawText("Made by LennyTheSniper", 10, 590, "white", 16);
    requestAnimationFrame(gameLoop);
    return;
  }

  if (!gameOver) {
    let elapsed = now - startTicks;
    if (elapsed >= 12000 && now - lastRamp > 8000 && arrowsPerSec < maxArrowsPerSec) {
      arrowsPerSec += 0.05;
      lastRamp = now;
    }
    if (elapsed >= 12000) octagonMode = true;

    if (++arrowTimer >= FPS / arrowsPerSec) {
      queueArrow();
      arrowTimer = 0;
    }

    while (arrowSpawnQueue.length && now >= arrowSpawnQueue[0].spawnTime) {
      arrows.push(arrowSpawnQueue.shift().arrow);
    }

    let dir = getDirectionFromKeys();
    if (dir !== null) shieldAngle = dir;

    updateArrows();
    drawArrows();
    drawSoul();
    drawShield();

    drawText(`Score: ${score}`, 10, 20);
    drawText(`High Score: ${highScore}`, 10, 45);
    drawText(`HP: ${hp}`, 10, 70);
    drawText(`Time: ${Math.floor(elapsed / 1000)}`, 10, 95);

    if (hp <= 0) {
      gameOver = true;
      music.pause();
      sfx_gameOver.play();
      highScore = Math.max(highScore, score);
    }
  } else {
    drawText("GAME OVER", 230, 280, "red", 32);
    drawText("Press R to Restart", 200, 320, "white", 20);
    drawText(`Score: ${score}`, 250, 360, "white", 18);
    drawText(`High Score: ${highScore}`, 230, 380, "white", 18);
  }

  requestAnimationFrame(gameLoop);
}

// Input handling
window.addEventListener("keydown", (e) => {
  keys[e.key] = true;
  if (startScreen) {
    startScreen = false;
    startTicks = Date.now();
    music.play().catch(() => {}); // Avoid autoplay error
  } else if (gameOver && e.key.toLowerCase() === "r") {
    arrows = [];
    arrowSpawnQueue = [];
    shieldAngle = 90;
    hp = 3;
    score = 0;
    arrowsPerSec = 2;
    octagonMode = false;
    arrowTimer = 0;
    lastRamp = Date.now();
    startTicks = Date.now();
    gameOver = false;
    music.currentTime = 0;
    music.play();
  }
});
window.addEventListener("keyup", e => delete keys[e.key]);

requestAnimationFrame(gameLoop);
</script>
</body>
</html>
